RPC factorial

struct numbers{
	int a;
};

program FACCAL{
	version FACCALVERS{
		int FACTO(numbers)=1;
	}=1;
}=0x21234567;

---
CLIENT

printf("Enter value: ");
	scanf("%d", &facto_1_arg.a);

printf("RESULT: %d", *result_1);
------
SERVER 
int *
facto_1_svc(numbers *argp, struct svc_req *rqstp)
{
	static int  result;
	static int fac=1, i;

	for(i=1; i <=argp->a; i++ ){
		fac = fac * i;
	}

	result = fac;
	

	return &result;
}

---

mkdir factoral
touch fac

rpcgen -aC fac.x
make -f Makefile.fac
sudo ./fac_server

sudo ./fac_client localhost

====RMI====
Hello.java
import java.rmi.*;
import java.rmi.server.*;

public class Hello extends UnicastRemoteObject implements HelloInterface{

	public Hello() throws RemoteException{}

	public String hello(){

		String name = "HELLO WORLD!";
		return name;
	}
}
-------
HelloClient.java

import java.rmi.*;

public class HelloClient{
	public static void main(String[] args) {
		try{
			HelloInterface hello1 = (HelloInterface) Naming.lookup("printhello");
			System.out.println(hello1.hello());
		}catch(Exception e){
			System.out.println("Error: " + e);
		}
		

	}
}
-----
HelloInterface.java

import java.rmi.*;

public interface HelloInterface extends Remote{
	public String hello() throws RemoteException;
}
----
HelloServe
import java.rmi.*;
import java.rmi.registry.*;

public class HelloServe{
	public static void main(String[] args) {
		try{
			Hello hello1 = new Hello();
			Naming.rebind("printhello", hello1);
			System.out.println("Server ready");
		}catch(Exception e){
			System.out.println("Error: " + e);
		}
	}
}
----
COMMAND

javac HelloInterface.java
javac Hello.java
javac HelloServe.java
javac HelloClient.java

rmic Hello
rmiregistry &
java HelloSerev

java HelloClient

===MPI===
mpi1.c file

#include <stdio.h>
#include <mpi.h>  ///*******

int main(int argc, char** argv){

	MPI_Init(NULL, NULL); //*******
	//////////////

	int world_size;
	MPI_Comm_size(MPI_COMM_WORLD, &world_size);  // no. of processors

	int world_rank;
	MPI_Comm_rank(MPI_COMM_WORLD, &world_rank); // rank number

	char processor_name[MPI_MAX_PROCESSOR_NAME];
	int name_len;
	MPI_Get_processor_name(processor_name, &name_len);

	printf("\nprocessor name %s, rank : %d, no of processors %d\n"
			, processor_name, world_rank, world_size);

	MPI_Finalize(); ///*****

	return 0;
}
----
mpicc mpi1.c -o mpi3
mpirun -np2 ./mpi3

====MPI CAL===

struct values{
	float a;
	float b;
	char op;
};

program CALCU{
	version VERCAL{
		float ADD(values) = 1;
		float SUB(values) = 2;
		float MUL(values) = 3;
		float DIV(values) = 4;

	} = 5;
} = 0x23456789;
----------
CLIENT
/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cal.h"


float
calcu_5(char *host,float n1,float n2,char op)
{
	CLIENT *clnt;
	float  *result_1;
	values  add_5_arg;
	float  *result_2;
	values  sub_5_arg;
	float  *result_3;
	values  mul_5_arg;
	float  *result_4;
	values  div_5_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, CALCU, VERCAL, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

if(op == '+'){

	add_5_arg.a = n1;
	add_5_arg.b = n2;

	result_1 = add_5(&add_5_arg, clnt);
		if (result_1 == (float *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	return * result_1;



}else if(op == '-'){

	sub_5_arg.a = n1;
	sub_5_arg.b = n2;

	result_2 = sub_5(&sub_5_arg, clnt);
	if (result_2 == (float *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	return * result_2;
}
else if (op == '*'){

	mul_5_arg.a = n1;
	mul_5_arg.b = n2;

	result_3 = mul_5(&mul_5_arg, clnt);
	if (result_3 == (float *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	return * result_3;
}
else if (op == '/'){

	div_5_arg.a = n1;
	div_5_arg.b = n2;

	result_4 = div_5(&div_5_arg, clnt);
	if (result_4 == (float *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	return * result_4;
}



#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host ,op;
	
	float n1,n2,result;

	printf("enter number 1 :");
	scanf("%f",&n1);
	printf("enter number 2 :");
	scanf("%f",&n2);
	printf("enter oparetor:");
	scanf("%s",&op);


	host = argv[1];
	result = calcu_5 (host,n1,n2,op);

	printf("value is : %.2f",result);

exit (0);
}

-----

SERVER

/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cal.h"

float *
add_5_svc(values *argp, struct svc_req *rqstp)
{
	static float  result;

	result = argp->a + argp->b;

	return &result;
}

float *
sub_5_svc(values *argp, struct svc_req *rqstp)
{
	static float  result;

	result = argp->a - argp->b;

	return &result;
}

float *
mul_5_svc(values *argp, struct svc_req *rqstp)
{
	static float  result;

	result = argp->a * argp->b;


	return &result;
}

float *
div_5_svc(values *argp, struct svc_req *rqstp)
{
	static float  result;

	result = argp->a / argp->b;


	return &result;
}






